# wenda-SNS-project
信息交流平台（仿知乎问答项目-SpringBoot）

# 1.注册登录功能实现：
数据库表格
````
login_ticket（id，user_id,ticket,expered,status）
user（id,name,password,salt,head_url）
````
用户登录注册成功后会使用 UUID 随机生成Ticket字符串，存储在数据库中和cookie中，下次用户登录时候会带上ticket；<br>
这个ticket要设置过期时间和状态（用于退出登录判断）<br>
使用拦截器Interceptor拦截用户的所有请求，判断请求中是否存在有效的ticket，如果有就将用户信息写入Threadlocal。<br>
所有线程的threadlocal都被存在一个叫做hostholder的实例中，根据该实例就可以在全局任意位置获取用户的信息。<br>
该ticket的功能类似session，也是通过cookie写回浏览器，浏览器请求时再通过cookie传递，区别是该字段是存在数据库中的，并且可以用于移动端。<br>
通过用户访问权限拦截器来拦截用户的越界访问，比如用户没有登录就跳转到登录界面。<br>
配置了json工具类以及md5工具类，并且使用Java自带的盐生成api将用户密码加密为密文。<br>
注册的时候生成salt存在用户表中，登录判断（MD5(password+User.salt) =? User.passWord）<br>
数据安全性的保障手段：https使用公钥加密私钥解密，比如支付宝的密码加密，单点登录验证，验证码机制等。
# 2.问题发布+敏感词过滤：
````
	Question（id,title,content,user_id,created_id,comment_count）
````	
发布问题时检查标题和内容，防止xss注入，并且过滤敏感词。<br>
防止xss注入直接使用HTMLutils的方法即可实现。<br>
过滤敏感词首先需要建立一个字典树，并且读取一份保存敏感词的文本文件，然后初始化字典树。最后将过滤器作为一个服务，让需要过滤敏感词的服务进行调用即可。

# 3.发表评论+站内信：
````
comment（id,content,user_id,crested_date,entity_id,entity_type,status）
message（id,fromid,toid,centent,conversion_id,created_date,has_read）
````
每一个问题下面都有评论，显示评论数量，具体内容，评论人等信息。<br>
消息的逻辑是，两个用户之间发送一条消息，有一个唯一的会话id，这个会话里可以有多条这两个用户的交互信息。通过一个用户id获取该用户的会话列表，再根据会话id再获取具体的会话内的多条消息。
# 4.Redis实现点赞点踩功能：

开发点踩和点赞功能，在此之前根据业务封装好jedis的增删改查操作，放在util包中。<br>
根据需求确定key字段，格式是（like：实体类型：实体id ）（dislike：实体类型：实体id ）这样可以将喜欢一条新闻的人存在一个集合，不喜欢的存在另一个集合。通过统计数量可以获得点赞和点踩数。<br>
一般点赞点踩操作是先修改redis的值并获取返回值，然后再异步修改mysql数据库的likecount数值。<br>
这样既可以保证点赞操作快速完成，也可保证数据一致性。
# 5.异步消息机制
在之前的功能中有一些不需要实时执行的操作或者任务，我们可以把它们改造成异步消息来进行发送。<br>
具体操作就是使用redis来实现异步消息队列。代码中使用事件event来包装一个事件，事件需要记录事件实体的各种信息：一个异步工具类（事件生产者+事件消费者+eventHandler接口），让以后各种事件的实现类来实现这个接口。<br>
事件生产者一般作为一个服务，由Controller中的业务逻辑调用并产生一个事件，将事件序列化存入redis队列中，事件消费者则通过一个线程循环获取队列里的事件，并且寻找对应的handler进行处理。
# 6.关注和粉丝列表的实现
新增关注功能，使用redis实现每一个关注对象的粉丝列表以及每一个用户的关注对象列表。通过该列表的crud操作可以对应获取粉丝列表和关注列表，并且实现关注和取关功能。<br>
由于关注成功和添加粉丝成功时同一个事务里的两个操作，可以使用redis的事务multi来包装事务并进行提交。<br>
除此之外，关注成功或者被关注还可以通过事件机制来生成发送邮件的事件，由异步的队列处理器来完成事件响应，同样是根据redis来实现。<br>
对于粉丝列表，除了显示粉丝的基本信息之外，还要显示当前用户是否关注了这个粉丝，以便前端显示。<br>
对于关注列表来说，如果被关注对象是用户的话，除了显示用户的基本信息之外，还要显示当前用户是被这个用户关注，以便前端显示。
# 7. 个性化首页推拉模式下的Feed流
````
feed（id,type,user_id,created_date,data,dataJson）
````
微博的新鲜事功能介绍：关注好友的动态（好友的点赞和发表的问题等），关注了某个问题，这些都是feed流的一部分。<br>
在知乎中的feed流主要体现于：关注用户的评论行为，关注用户的关注问题行为。<br>
feed流主要分为两种，推模式和拉模式。推模式主要是把新鲜事推送给关注该用户的粉丝，本例使用redis来存储某个用户接受的新鲜事id列表，这个信息流又称为timeline，根据用户的唯一key来存储；拉模式主要是用户直接找寻自己所有关注的人，并且到数据库去查找这些关注对象的新鲜事，直接返回。<br>
推模式主要适合粉丝较少的小用户，因为他们的粉丝量少，使用推模式产生的冗余副本也比较少，并且可以减少用户访问的压力。<br>
拉模式主要适合大v，因为很多僵尸粉和非活跃用户根本不需要推送信息，用推模式发给这些僵尸粉或者非活跃用户就是浪费资源。所以让用户通过拉模式请求，只需要一个数据副本即可。同时如果是热点信息，这些信息也可以放在缓存，让用户首先拉取这些信息，提高查询效率。<br>
使用feedhandler异步处理上述的两个事件，当事件发生时，根据事件实体进行重新包装，构造一个新鲜事，因为所有新鲜事的格式是一样的。需要包括：日期，新鲜事类型，发起者，新鲜事内容，然后把该数据存入数据库，以便用户使用pull模式拉出。<br>
为了适配推送模式，此时也要把新鲜事放到该用户所有粉丝的timeline里，这样的话就同时实现了推和拉的操作了。
